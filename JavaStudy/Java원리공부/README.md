# 자바 원리 공부

## JAVA의 특징

- JVM을 이용하기에 운영체제에 독립적이다.
- 객체지향 언어이기에 상속, 추상화, 다형성, 캡슐화의 특징을 가진다.
- 런타임시 데이터 타입이 결정되는 동적 타입 언어이다.
- 컴파일 언어와 인터프리터 언어 2가지 동작방식을 복합적으로 가지는 하이브리드 언어이다.

## Java 접근제어자

- public : 모든 패키지, 모든 클래스의 접근 허용
- protected : 같은 패키지, 모든 클래스의 접근 허용 (단, 다른 패키지인 경우 자식 클래스의 접근 허용)
- default : 같은 패키지 내 클래스만 접근 허용
- private : 같은 클래스 내 접근만 허용

## final

- 클래스, 메서드, 변수가 변하지 않도록 함
- 데이터를 ReadOnly로 만듬

## 인터페이스와 추상 클래스 차이

- 추상 클래스 : abstract로 선언되거나 추상메서드를 하나 이상 포함한 클래스
  - 클래스이기에 하나만 상속이 가능
  - 하위 클래스에게 메소드의 구현을 강제함
  - extends 키워드 사용. 하나만 가능
- 인터페이스 : 구현체 없이 메서드에 대한 명체만 가지고 있고 모든 메서드가 추상메서드
  - 인터페이스를 상속받는 자식클래스에 모든 메서드에 대한 구현을 강제, 다중 상속이 가능
  - implements 키워드 사용. 여러개 가능

## 오버라이딩 vs 오버로딩

- 오버라이딩
  - 하위 클래스에서 상위 클래스의 메소드를 재정의하여 사용
  - 상위 클래스의 기능을, 하위클래스에서 필요한 부분만 재수정하여 원하는 기능으로 구현하는 것
  - 코드 중복을 줄이고, 기능 확장 가능
- 오버로딩
  - 같은 이름을 가지는 메소드를 여러개 가지는 것을 말함
  - 메소드의 이름은 같지만, 매개변수의 개수, 타입을 다르게 함
    - 같은 메소드의 이름을 다른 기능으로 재정의하여 사용
  - 메소드 이름 1개로 여러 기능으로 재정의 하여 사용
- 둘 다 하나의 이름으로 여러 역할을 할 수 있도록 하여 다형성의 특징을 가짐

## Generic

- 데이터 타입을 일반화하는 것
- 데이터 타입을 컴파일 시 미리 지정하는 것
- 장점
  - 컴파일 시 타입을 명시해주기 때문에 의도하지 않은 형변환을 막을 수 있음

## static

- 정적 멤버를 만들 수 있는 키워드
- 정적 필드와 메소드는 인스턴스가 아닌, 클래스에 고정되어 메모리 영역에 적재할 때 정적 메모리로 사용 가능
- 객체 멤버는 객체를 생설할 때, 힙 영역에 할당 됨

## java의 main 메소드가 static인 이유

- 메모리가 초기화 된 순간 객체는 하나도 존재하지 않기에 객체 멤버 메서드는 바로 실행할 수 없음
- 객체의 존재 여부에 관계없이 쓰기 위해. static 멤버는 JVM 구동시 스태틱 영역에 바로 배치 됨

## JVM의 동작과정 및 원리

### 원리

- 컴퓨터가 자바 바이트 코드를 운영체제에 맞게 실행시키는 역할 수행
- OS의 종류에 상관없이 자바 파일을 실행할 수 있도록 하는 중개자 역할. 따라서 자바는 플랫폼 독립적 특성을 가짐

### 동작과정

- 프로그램이 실행되면 JVM은 OS로부터 필요한 메모리 할당
- 자바 컴파일러가 자바 소스를 읽어들여 자바 바이트코드로 변환
- class loader을 통해 class 파일들을 JVM으로 로딩 함
- 로딩된 class 파일들은 Excution engine을 통해 해석
- 해석된 바이트 코드는 Runtime Data Areas에 배치되어 실질적인 수행을 함

### JVM 구조

- JVM의 구조는 Class Loader, Exection engine, Runtime Data Area, Garbage Collector로 이루어져 있음
- Class Loader - 자바 컴파일러가 .java 파일을 컴파일하여 .class 파일(바이트 코드)이 생성되면,
  이 생성된 클래스 파일들을 엮어 Runtime Data Area 형태로 메모리에 적재하는 역할을 합니다.
- Execution Engine
  - 클래스 로더를 통해 JVM 내의 Runtime Data Area에 배치된 바이트 코드들을 명령어단위로 읽어서 실행합니다. 메모리에 적재된 클래스들을 기계어로 변경해 명령어 단위로 실행하는 역할을 합니다.
- Garbage Collector
  - Heap 메모리 영역에 생성 된 객체들 중에 참조되지 않는 객체들을 탐색 후 제거하는 역할을 합니다.
- Runtime Data Area
  - VM이 프로그램을 수행하기 위해 OS로 부터 별도로 할당 받은 메모리 공간
    - 모든 스레드 공유 영역
      - Method Area
        - 메소드 영역에서 자바 프로그램의 클래스 코드, 변수 코드, static, final 변수 등이 생성
      - Heap Area
        - new 키워드로 생성한 객체가 저장되는 영역
        - 동적으로 생성된 객체와 배열이 저장되는 곳으로 Garbage Collection의 대상이 되는 영역
      - Stack Area
        - 지역 변수, 파라미터 등이 생성되는 영역, 동적으로 객체를 생성하면 실제 객체는 Heap에 할당되고 해당 레퍼런스만 Stack에 저장
        - Heap에 있는 객체가 Stack에서 참조 할 수 없는 경우 GC의 대상이 된다.
    - 각 스레드 별 생성 영역
      - PC Register
        - 현재 쓰레드가 실행되는 부분의 주소와 명령을 저장
      - Native Method
        - 자바외 언어로 작성된 네이티브 코드를 위한 메모리 영역

## GC(Garbage Collector)의 종류와 동작 과정, 원리

- 힙 메모리 관리를 위해, 참조되고 있지 않은 객체들을 메모리에서 삭제하는 역할
- 제거되는 경우
  - 객체는, 힙영역에 저장되고, 스택 영역에 이를 가르키는 주소값이 저장되는데, 힙영역에서 자신을 가르키는 주소값이 없으면, 참조되고 있지 않는다고 판단
    - GC가 동작을 하면, GC Root부터 객체를 찾고, 그 객체가 참조하는 객체를 찾아 mark 함
    - Mark되지 않은 객체는 접근할 수 없다고 판단하여 제거

### GC 동작 과정

    - 객체가 생성되면 메모리를 young 영역에 저장
    - 객체를 최초 생성하면 Young 영역에 Eden 영역에 위치
    - Eden 영역에서 Minor GC가 발생하면, 참조 중인 객체는 1번 Survivor 영역으로 이동
    - 1번 Survivor 영역에서 Minor GC가 발생하면, 참조 중인 객체는 2번 Survivor 영역으로 이동하고 1번 Survivor 영역은 비게됨
    - Young 영역에서 오래 살아남은 객체는 Old영역으로 이동
    - Old 영역에 있는 객체는 Major GC가 발생했을 때, 참조 여부에 따라 유지되거나 제거

### GC 알고리즘 종류

- Serial GC
  - 가장 단순한 방식한 GC
  - 싱글 스레드로 동작하고, 그만큼 느림
  - Mark-sweep-compact 알고리즘
- Paraller GC
  - Java8의 default GC
  - Serial GC와 알고리즘은 같지만 GC를 처리하는 Thread가 여러개
- Paraller Old GC
  - Paraller GC는 Young영역에서만 멀티스레드를 사용
  - 이건 Old 영역까지 멀티스레드를 사용
  - Paraller GC에서 Old GC 알고리즘을 개선한 버전
